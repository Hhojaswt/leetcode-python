## 1.双指针
- a.双指针的类型通常分为以下几种， 有**对撞，快慢和普通**。
  <img width="1798" height="1290" alt="image" src="https://github.com/user-attachments/assets/68451c09-704a-4a80-862c-021ece1c2ff2" />

  在这里举了一个例子，既可以使用对撞也可以使用快慢。对撞在这里时间复杂度更小，可以通过比大小的方式，假如两数相加小于12那么移动两边的指针直到找到合适的两个数相加。

- b. **141题**环形链表
<img width="1434" height="1089" alt="image" src="https://github.com/user-attachments/assets/bb87ee7c-3885-4aa9-86ff-67805cf708aa" />

在这里可以使用快慢指针，一个指针是慢指针，一个是快指针，快指针比慢指针多移动两个格子，在这里如果是有头有尾的链表那么快慢指针永远不会交汇，但假设有环可以相遇
<img width="558" height="383" alt="image" src="https://github.com/user-attachments/assets/74c84f3f-50ac-4637-9c01-64074c420b2d" />

这里在条件判断中只写了快指针，假如快指针到达了链表的末尾那么就表明这个链表有结尾那么就需要return false：
<img width="733" height="603" alt="image" src="https://github.com/user-attachments/assets/f7f44a28-7a8d-4d48-89fe-3b4ce14d3f2e" />

完整代码如下所示：
https://www.bilibili.com/opus/469902407532964755/?from=readlist

- c. **881** 救生艇
  <img width="846" height="613" alt="image" src="https://github.com/user-attachments/assets/9eb6fd90-7d0e-4304-9136-c0f32204334f" />

这题的思路可以先排序，这样通过对撞指针可以看出最大的哪个数是否可以和最小的数组合在一起
<img width="726" height="449" alt="image" src="https://github.com/user-attachments/assets/0a236419-1d94-45a0-8991-af9d491dc43a" />
<img width="839" height="593" alt="image" src="https://github.com/user-attachments/assets/46767c20-35a9-4fba-8509-3f5e2d30da43" />


## 2. 二分查找法
- a. 如果要猜测一个数字，随便猜测会花费很多时间，如果规定一个范围是在50以上还是50以下等等，进行范围搜索就是二分查找法。如题所示如果想要找6，可以先从中间开始，看比起目标值是大还是小。
  <img width="814" height="526" alt="image" src="https://github.com/user-attachments/assets/a443640a-9f28-4300-b926-735cd99a246e" />

- b. **704**二分查找
  <img width="669" height="469" alt="image" src="https://github.com/user-attachments/assets/ffb350cd-13a1-496c-a2d3-51ee5b6e187c" />

可以先设置left和right指针，两者相除得到mid指针，找到后再将l指针移动到mid指针左侧，再两者相除
<img width="692" height="332" alt="image" src="https://github.com/user-attachments/assets/6bc129de-43ae-4db5-9cbc-346dcfb5626a" />
<img width="780" height="540" alt="image" src="https://github.com/user-attachments/assets/5ea45269-747f-43f8-a34a-a6beeb2fdeb5" />
<img width="694" height="298" alt="image" src="https://github.com/user-attachments/assets/fe009c00-db11-44c9-8ed1-71591ed8468d" />

具体情况可以看下列连接：https://www.bilibili.com/opus/470221394759608480/?from=readlist

- c.**74**搜索二维矩阵
  <img width="553" height="416" alt="image" src="https://github.com/user-attachments/assets/038a81c1-6099-4cc1-91ce-4b0e4f108497" />
  <img width="891" height="606" alt="image" src="https://github.com/user-attachments/assets/526e4e4e-d98c-41a8-8c68-d0640c83e164" />

  这题的关键是将二维索引转换为一维索引再转换回来。
  <img width="840" height="511" alt="image" src="https://github.com/user-attachments/assets/22fd7081-a7e4-4df9-b092-34e3e1d2ea82" />
  <img width="806" height="615" alt="image" src="https://github.com/user-attachments/assets/84a81add-93db-4e7e-9ba6-d5e20fb154fe" />

## 3.递归
- a.递归需要满足几种以下的条件:
<img width="1395" height="1081" alt="image" src="https://github.com/user-attachments/assets/8516b28f-44be-44b7-ba1c-6cb0546c282b" />

例如如下的斐波那契数列，每一个数都是前两个数的和：
<img width="860" height="635" alt="image" src="https://github.com/user-attachments/assets/ac21c9a8-2cb2-4054-b439-ea9ef3e4b573" />
从上到下遍历完以后还需要返回回去，因此称作递归

- b. **509**斐波那契数列 题目如下所示：
  <img width="772" height="501" alt="image" src="https://github.com/user-attachments/assets/8964beaa-a973-4052-8c3c-1e7cb1713dd7" />
  <img width="845" height="591" alt="image" src="https://github.com/user-attachments/assets/6bf816a4-af04-4053-a241-1dc4ba2e044a" />
可以将数列拆解为上述形式，这样就可以知道数列的终止条件是0和1，以及具体如何拆解。
具体代码如下所示：https://www.bilibili.com/opus/472154147216604412/?from=readlist

- c. **206**反转链表 题目如下所示：
<img width="741" height="506" alt="image" src="https://github.com/user-attachments/assets/eb035ce0-14d4-4305-8284-9ce94d45126e" />

这题同样可以用递归函数来做，将链表尾部的指针返回指向上一个值：
<img width="1581" height="1142" alt="image" src="https://github.com/user-attachments/assets/0189a9f4-da96-4b0d-936e-6e6a13b07dc1" />
<img width="831" height="569" alt="image" src="https://github.com/user-attachments/assets/55902d95-bf6a-4780-a0b8-761eea4249c7" />


## 3.分治法
-a.基本概念：
<img width="1338" height="1005" alt="image" src="https://github.com/user-attachments/assets/721c053e-54cd-4839-b35d-649ed98045df" />
分治法是将这几个数不断对半分，逐级分解再进行两两合并排序，最终可以输出原始大问题的解：
<img width="819" height="518" alt="image" src="https://github.com/user-attachments/assets/47c4da02-7cf8-431d-98c5-9cb75ba507d3" />

-b. **53**.最大子序合
<img width="812" height="587" alt="image" src="https://github.com/user-attachments/assets/76b57dd8-9f98-4e7c-ab43-ec67fef63e30" />

如果一分为二，最大子序列要不是在左边，要不是在右边，要不是在中间
<img width="872" height="492" alt="image" src="https://github.com/user-attachments/assets/312ad2f2-bbc5-4102-b1c2-acbb9575bfc2" />

先设置一个递归终止，再求左边右边最大值
<img width="928" height="630" alt="image" src="https://github.com/user-attachments/assets/d5e3f702-26ff-4a69-a4b2-61e20a00e968" />
<img width="930" height="504" alt="image" src="https://github.com/user-attachments/assets/bda4f731-28af-4db3-b70b-509c5c7d0dcb" />


## 4. 回溯法
- a. **22**括号生成
  <img width="1777" height="1134" alt="image" src="https://github.com/user-attachments/assets/fc0f92fb-2443-43ac-b681-445380b02eb5" />
<img width="1883" height="1177" alt="image" src="https://github.com/user-attachments/assets/13f5c04a-44a8-4c9f-94f4-bcbce03c295b" />
<img width="1210" height="608" alt="image" src="https://github.com/user-attachments/assets/7f7da096-737f-4ff5-aa2a-1fc148fec16e" />
<img width="1116" height="637" alt="image" src="https://github.com/user-attachments/assets/cb7b6faa-37e1-4142-88a8-d9683240eca1" />
<img width="1186" height="624" alt="image" src="https://github.com/user-attachments/assets/b8b6cae1-7378-4c1e-a190-078a7d4738b0" />















